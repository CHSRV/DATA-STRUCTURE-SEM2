<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEBULA CORE: PROTOCOL 5</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=JetBrains+Mono:wght@300;500&display=swap');
        
        body { margin: 0; overflow: hidden; background: #000; color: #00f2ff; font-family: 'JetBrains Mono', monospace; }

        /* Tech HUD Layout */
        #ui-panel {
            position: absolute; top: 40px; left: 40px; width: 300px;
            background: rgba(0, 10, 15, 0.85); padding: 30px;
            border: 1px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(15px); pointer-events: all;
            box-shadow: 0 0 40px rgba(0,0,0,0.8); z-index: 100;
        }

        h1 { font-family: 'Syncopate', sans-serif; font-size: 14px; letter-spacing: 6px; margin: 0 0 30px 0; color: #fff; }
        
        .stat { margin-bottom: 20px; }
        .stat-label { font-size: 9px; opacity: 0.5; letter-spacing: 2px; }
        .stat-value { font-size: 14px; color: #00f2ff; }

        /* NATURAL CAMERA FEED */
        #camera-wrapper {
            position: absolute; bottom: 40px; right: 40px; 
            width: 240px; height: 180px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 100;
        }
        #camera-feed {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* Mirror for natural movement */
        }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 30px; }
        .btn { 
            border: 1px solid rgba(0, 242, 255, 0.4); padding: 12px; font-size: 10px; 
            text-align: center; cursor: pointer; transition: 0.2s; background: rgba(0,0,0,0.3);
        }
        .btn:hover, .btn.active { background: #00f2ff; color: #000; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui-panel">
    <h1>CORE_INTERFACE</h1>
    
    <div class="stat">
        <div class="stat-label">NEURAL_LINK</div>
        <div id="hand-status" class="stat-value">AWAITING HAND...</div>
    </div>
    
    <div class="stat">
        <div class="stat-label">ACTIVE_PROTOCOL</div>
        <div id="protocol-name" class="stat-value">NEBULA_GENESIS</div>
    </div>

    <div class="btn-grid">
        <div class="btn active" onclick="setMode(0, 'GENESIS')">NEBULA</div>
        <div class="btn" onclick="setMode(1, 'VITAL_SIGN')">HEART_3D</div>
        <div class="btn" onclick="setMode(2, 'JOVIAN_FLOW')">JUPITER</div>
        <div class="btn" onclick="setMode(3, 'RING_SYSTEM')">SATURN</div>
        <div class="btn" onclick="setMode(4, 'DATA_STREAM')" style="grid-column: span 2; border-color: #ff00ff; color: #ff00ff;">ACTIVATE MATRIX</div>
    </div>
</div>

<div id="camera-wrapper">
    <video id="camera-feed" autoplay playsinline></video>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
// --- SHADER SYSTEM ---
const _VS = `
    uniform float uTime;
    uniform float uExpansion;
    uniform float uMorph;
    uniform int uMode;
    attribute vec3 targetPos;
    varying vec3 vColor;

    void main() {
        vec3 morphed = mix(position, targetPos, uMorph);
        
        if(uMode == 4) {
            // Data Rain physics
            morphed.y = mod(morphed.y - uTime * 8.0, 30.0) - 15.0;
        }

        vec3 finalPos = morphed * uExpansion;
        
        // Color mapping
        if(uMode == 4) {
            vColor = vec4(0.0, 1.0, 0.4, 1.0).rgb;
        } else {
            vColor = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.0, 0.5), (morphed.y + 5.0) / 10.0);
        }

        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
        gl_PointSize = (90.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const _FS = `
    varying vec3 vColor;
    void main() {
        float r = length(gl_PointCoord - vec2(0.5));
        if (r > 0.5) discard;
        gl_FragColor = vec4(vColor, pow(1.0 - r*2.0, 2.5));
    }
`;

// --- THREE SCENE SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const COUNT = 35000;
const geo = new THREE.BufferGeometry();
const basePos = new Float32Array(COUNT * 3);
const targetPosArr = new Float32Array(COUNT * 3);

function updateGeometry(mode) {
    for (let i = 0; i < COUNT; i++) {
        const i3 = i * 3;
        const t = Math.random() * 6.28, p = Math.acos(2 * Math.random() - 1);

        if (mode === 0) { // Nebula
            const r = 5 + Math.random() * 2;
            targetPosArr[i3] = r * Math.sin(p) * Math.cos(t);
            targetPosArr[i3+1] = r * Math.sin(p) * Math.sin(t);
            targetPosArr[i3+2] = r * Math.cos(p);
        } else if (mode === 1) { // 3D Heart
            const r = 4;
            targetPosArr[i3] = r * Math.pow(Math.sin(p), 3) * Math.sin(t);
            targetPosArr[i3+1] = r * (Math.cos(p) - Math.pow(Math.sin(p), 2));
            targetPosArr[i3+2] = r * Math.cos(t) * Math.sin(p);
        } else if (mode === 2) { // Jupiter
            const r = 5;
            targetPosArr[i3] = r * Math.sin(p) * Math.cos(t);
            targetPosArr[i3+1] = r * Math.sin(p) * Math.sin(t) * 0.7;
            targetPosArr[i3+2] = r * Math.cos(p);
        } else if (mode === 3) { // Saturn
            if (i < COUNT * 0.4) { 
                const r = 3;
                targetPosArr[i3] = r * Math.sin(p) * Math.cos(t);
                targetPosArr[i3+1] = r * Math.sin(p) * Math.sin(t);
                targetPosArr[i3+2] = r * Math.cos(p);
            } else {
                const rr = 5.5 + Math.random() * 2.5;
                targetPosArr[i3] = rr * Math.cos(t);
                targetPosArr[i3+1] = (Math.random()-0.5)*0.15;
                targetPosArr[i3+2] = rr * Math.sin(t);
            }
        } else if (mode === 4) { // Data Stream
            targetPosArr[i3] = (Math.random() - 0.5) * 25.0;
            targetPosArr[i3+1] = (Math.random() - 0.5) * 25.0;
            targetPosArr[i3+2] = (Math.random() - 0.5) * 8.0;
        }
    }
    geo.setAttribute('targetPos', new THREE.BufferAttribute(new Float32Array(targetPosArr), 3));
}

for(let i=0; i<COUNT*3; i++) basePos[i] = (Math.random()-0.5)*25;
geo.setAttribute('position', new THREE.BufferAttribute(basePos, 3));
updateGeometry(0);

const mat = new THREE.ShaderMaterial({
    uniforms: { uTime: {value: 0}, uExpansion: {value: 1}, uMorph: {value: 0}, uMode: {value: 0} },
    vertexShader: _VS, fragmentShader: _FS, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
});

const points = new THREE.Points(geo, mat);
scene.add(points);
camera.position.z = 18;

// --- HAND TRACKING ---
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8 });

hands.onResults((res) => {
    const statusEl = document.getElementById('hand-status');
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        statusEl.innerText = "LINK_ACTIVE";
        statusEl.style.color = "#00f2ff";
        const h = res.multiHandLandmarks[0];
        const dist = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
        
        mat.uniforms.uExpansion.value = THREE.MathUtils.lerp(mat.uniforms.uExpansion.value, 0.4 + dist * 14, 0.1);
        mat.uniforms.uMorph.value = THREE.MathUtils.lerp(mat.uniforms.uMorph.value, 1.0, 0.05);
        points.rotation.y += 0.005;
        points.rotation.x = THREE.MathUtils.lerp(points.rotation.x, (h[8].y - 0.5) * 2.0, 0.1);
    } else {
        statusEl.innerText = "SCANNING...";
        statusEl.style.color = "#ff3366";
        mat.uniforms.uMorph.value = THREE.MathUtils.lerp(mat.uniforms.uMorph.value, 0.0, 0.02);
    }
});

const cam = new Camera(document.getElementById('camera-feed'), {
    onFrame: async () => { await hands.send({image: document.getElementById('camera-feed')}); },
    width: 640, height: 480
});
cam.start();

function setMode(val, name) {
    mat.uniforms.uMode.value = val;
    document.getElementById('protocol-name').innerText = name;
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    event.currentTarget.classList.add('active');
    updateGeometry(val);
}

function animate() {
    requestAnimationFrame(animate);
    mat.uniforms.uTime.value += 0.015;
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
